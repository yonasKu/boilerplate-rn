rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // ===== HELPER FUNCTIONS =====
    function isAuthenticated() {
      return request.auth != null;
    }
    
    function isOwner(userId) {
      return isAuthenticated() && request.auth.uid == userId;
    }
    
    function isEmailVerified() {
      return isAuthenticated() && request.auth.token.email_verified == true;
    }
    
    function isFamilyMember(parentUserId) {
      return isAuthenticated() && 
        (request.auth.uid == parentUserId || 
         (get(/databases/$(database)/documents/users/$(request.auth.uid)).data.parentUserId == parentUserId));
    }
    
    function hasSubscriptionAccess(userId) {
      return isAuthenticated() && 
        (get(/databases/$(database)/documents/subscriptionStatus/$(userId)).data.status == 'active' ||
         get(/databases/$(database)/documents/subscriptionStatus/$(userId)).data.status == 'trial');
    }

    function isBackendFunction() {
      // Allow server-side access from Firebase Admin SDK where auth is null
      return request.auth == null;
    }

    // Account type from custom claims: treat missing value as 'full' for backward compatibility
    function isFullAccount() {
      return isAuthenticated() && (request.auth.token.accountType == 'full' || request.auth.token.accountType == null);
    }

    // Shared access check using predictable doc id: `${ownerId}_${viewerId}` stored in `sharedAccess/{id}`
    function hasSharedAccessToOwner(ownerId) {
      return isAuthenticated() && exists(/databases/$(database)/documents/sharedAccess/$(ownerId + '_' + request.auth.uid));
    }

    // ===== USERS COLLECTION =====
    match /users/{userId} {
      // Allow create if the user is creating their own document and passes validation
      allow create: if isOwner(userId)
        && request.resource.data.name is string
        && request.resource.data.name.size() > 0
        && request.resource.data.email is string
        && request.resource.data.email == request.auth.token.email
        && request.resource.data.email.matches('.*@.*\\..*')
        && request.resource.data.onboarded == false
        && request.resource.data.lifestage == null
        && request.resource.data.subscription is map
        && request.resource.data.subscription.plan is string
        && request.resource.data.subscription.status is string
        && request.resource.data.subscription.startDate is timestamp
        && request.resource.data.children is list
        && request.resource.data.children.size() == 0
        && request.resource.data.createdAt is timestamp
        && request.resource.data.onboarded is bool;
    
      // Allow reading own data, if a family member, or if it's a backend function.
      // Backend functions can list all users.
      allow read, list: if isOwner(userId) || isFamilyMember(userId) || hasSharedAccessToOwner(userId) || isBackendFunction();

      // Allow owner to update their document.
      // Full accounts can update any fields EXCEPT 'subscription' (server-only); viewer accounts are restricted to name/profileImageUrl/updatedAt.
      // Family members retain limited updates as listed below.
      // Backend functions may update only the 'subscription' and 'updatedAt' fields.
      allow update: if
        (
          // Owner updates (full account) but cannot modify 'subscription'
          isOwner(userId) && isFullAccount() && !request.resource.data.diff(resource.data).affectedKeys().hasAny(['subscription'])
        ) || (
          // Owner updates (viewer account) limited to profile fields
          isOwner(userId) && request.resource.data.diff(resource.data).affectedKeys().hasOnly(['name', 'profileImageUrl', 'updatedAt'])
        ) || (
          // Family member limited updates
          isFamilyMember(userId) && request.resource.data.diff(resource.data).affectedKeys().hasOnly([
            'profile', 'permissions', 'updatedAt', 'subscriptionStatus', 'children'
          ])
        ) || (
          // Backend-only update for subscription snapshot
          isBackendFunction() && request.resource.data.diff(resource.data).affectedKeys().hasOnly(['subscription', 'updatedAt'])
        );
      
      // Only the owner can delete their own document
      allow delete: if isOwner(userId);

      // --- Sub-collection for children (fallback data model) ---
      match /children/{childId} {
        // Backend can read and list children in this subcollection.
        // Owners can also manage their own children here.
        allow read, list: if isOwner(userId) || isBackendFunction();
        allow write: if isOwner(userId);
      }

      // --- Sub-collection for device tokens for push notifications ---
      match /devices/{deviceToken} {
        // Only the owner of the user document can manage their own device tokens.
        allow read, write: if isOwner(userId);
      }

      // --- Sub-collection for user's notification preferences ---
      match /notificationPreferences/{prefId} {
        // Only the owner can manage their notification preferences.
        allow read, write: if isOwner(userId);
      }
      
    }

    // ===== WEBHOOK AUDIT LOGS =====
    // Store raw RevenueCat events for debugging/audit. Backend-only.
    match /revenuecatEvents/{eventId} {
      allow read, write: if isBackendFunction();
    }

    // ===== NOTIFICATIONS COLLECTION =====
    match /notifications/{notificationId} {
      // Allow read access for authenticated users who own the notification
      allow read, update: if isAuthenticated() && resource.data.userId == request.auth.uid;
      // Allow list for queries by the owner
      allow list: if isAuthenticated();
      // Notifications should only be created by the backend, not the client.
      allow create, delete: if isBackendFunction();
    }

    // ========== CHILDREN COLLECTION ==========
    match /children/{childId} {
      // Users can read children documents they own. Backend can read and list them.
      allow read, list: if (request.auth != null && request.auth.uid == resource.data.parentId) || hasSharedAccessToOwner(resource.data.parentId) || isBackendFunction();

      // Users can create children documents for themselves
      allow create: if request.auth != null 
        && request.resource.data.parentId == request.auth.uid
        && request.resource.data.keys().hasAll(['parentId', 'name', 'dateOfBirth', 'gender', 'createdAt', 'updatedAt'])
        && request.resource.data.name is string
        && request.resource.data.name.size() > 0
        && (request.resource.data.dateOfBirth is timestamp || request.resource.data.dateOfBirth is string)
        && request.resource.data.gender in ['Boy', 'Girl', 'other', 'prefer_not_to_say', "Don't know yet"];

      // Users can update or delete children documents they own
      allow update, delete: if request.auth != null && request.auth.uid == resource.data.parentId;
    }

    // ===== JOURNAL ENTRIES COLLECTION =====
    match /journalEntries/{entryId} {
      // A user can create an entry if they are logged in and the entry's `userId` field matches their own ID.
      allow create: if isOwner(request.resource.data.userId) && isFullAccount()
        && request.resource.data.keys().hasAll(['userId', 'childIds', 'text', 'createdAt', 'updatedAt'])
        && request.resource.data.childIds is list
        && request.resource.data.childIds.size() > 0
        && request.resource.data.text is string
        && request.resource.data.text.size() > 0
        && request.resource.data.isMilestone is bool
        && request.resource.data.isFavorited is bool
        && request.resource.data.media is list;
      
      // Read if owner or has shared access to the owner's timeline, or backend can read them.
      allow read: if isOwner(resource.data.userId) || hasSharedAccessToOwner(resource.data.userId) || isBackendFunction();
      
      // A user can update their own entry's content and tags.
      // Family members can also update likes and favorites.
      allow update: if (
        // Owners can always toggle interactions (no full-account requirement)
        (isOwner(resource.data.userId) &&
          request.resource.data.diff(resource.data).affectedKeys().hasOnly(['likes', 'isFavorited', 'isMilestone', 'updatedAt'])
        ) ||
        // Owners with full accounts can modify content/media/children fields
        (isOwner(resource.data.userId) && isFullAccount() &&
          request.resource.data.diff(resource.data).affectedKeys().hasOnly(['text', 'isFavorited', 'isMilestone', 'media', 'updatedAt', 'likes', 'childIds', 'childAgeAtEntry'])
        ) ||
        // Shared viewers can toggle likes and favorites
        (hasSharedAccessToOwner(resource.data.userId) &&
          request.resource.data.diff(resource.data).affectedKeys().hasOnly(['likes', 'isFavorited'])
        )
      );
      
      // A user can delete their own entry
      allow delete: if isOwner(resource.data.userId) && isFullAccount();
    }

    // ===== RECAPS COLLECTION =====
    match /recaps/{recapId} {
      // Read if owner or has shared access to the owner's timeline, or backend can read them.
      allow read: if isOwner(resource.data.userId) || hasSharedAccessToOwner(resource.data.userId) || isBackendFunction();

      // Owners (full accounts) or the backend can create recaps
      allow create: if ((isOwner(request.resource.data.userId) && isFullAccount()) || isBackendFunction())
        && request.resource.data.keys().hasAll(['userId', 'childId', 'type', 'period', 'status', 'createdAt', 'imageMetadata'])
        && request.resource.data.type in ['daily', 'weekly', 'monthly', 'yearly']
        && request.resource.data.status in ['generating', 'completed', 'failed']
        && request.resource.data.createdAt is timestamp
        && request.resource.data.imageMetadata is map
        && request.resource.data.imageMetadata.keys().hasAll(['count', 'hasImages', 'imageTypes'])
        && request.resource.data.imageMetadata.count is number
        && request.resource.data.imageMetadata.hasImages is bool
        && request.resource.data.imageMetadata.imageTypes is list;

      // Owners can update content and interactions based on account type; family members can update interactions.
      allow update: if (
        // Owners can always toggle interactions
        (isOwner(resource.data.userId) &&
          request.resource.data.diff(resource.data).affectedKeys().hasOnly(['likes', 'isFavorited', 'isMilestone', 'commentCount', 'lastCommentAt', 'updatedAt'])
        ) ||
        // Owners with full accounts can also modify content/status
        (isOwner(resource.data.userId) && isFullAccount() &&
          request.resource.data.diff(resource.data).affectedKeys().hasOnly(['content', 'status', 'isFavorited', 'updatedAt', 'isMilestone', 'commentCount', 'lastCommentAt', 'likes'])
        ) ||
        // Shared viewers can toggle interactions
        (hasSharedAccessToOwner(resource.data.userId) &&
          request.resource.data.diff(resource.data).affectedKeys().hasOnly(['likes', 'isFavorited', 'commentCount', 'lastCommentAt', 'isMilestone'])
        )
      );

      // Owners can delete their recaps
      allow delete: if isOwner(resource.data.userId) && isFullAccount();
    }

    // ===== RECAP COMMENTS COLLECTION =====
    match /recapComments/{commentId} {
      // Only users who can read the parent recap can read its comments.
      allow read: if isAuthenticated()
        && exists(/databases/$(database)/documents/recaps/$(resource.data.recapId))
        && (isOwner(get(/databases/$(database)/documents/recaps/$(resource.data.recapId)).data.userId)
            || hasSharedAccessToOwner(get(/databases/$(database)/documents/recaps/$(resource.data.recapId)).data.userId)
            || isBackendFunction());

      // Users can create comments for a recap if they are authenticated and own the comment.
      // Validate optional image-specific fields when present.
      allow create: if isAuthenticated()
        && request.resource.data.userId == request.auth.uid
        && exists(/databases/$(database)/documents/recaps/$(request.resource.data.recapId))
        && (isOwner(get(/databases/$(database)/documents/recaps/$(request.resource.data.recapId)).data.userId)
            || hasSharedAccessToOwner(get(/databases/$(database)/documents/recaps/$(request.resource.data.recapId)).data.userId)
            || isBackendFunction())
        && request.resource.data.keys().hasAll(['userId', 'recapId', 'text', 'createdAt'])
        && request.resource.data.text is string && request.resource.data.text.size() > 0
        // Optional image fields
        && (!('imageUrl' in request.resource.data) || request.resource.data.imageUrl is string)
        && (!('imageThumbUrl' in request.resource.data) || request.resource.data.imageThumbUrl is string)
        && (!('imageIndex' in request.resource.data) || request.resource.data.imageIndex is int)
        && (!('imageStoragePath' in request.resource.data) || request.resource.data.imageStoragePath is string);

      // Users can delete their own comments.
      allow delete: if isAuthenticated() && resource.data.userId == request.auth.uid;
    }

    // ===== FAMILY SHARING COLLECTIONS =====
    
    // Helper functions for family sharing
    function hasSharedAccess(ownerId, viewerId) {
      return exists(/databases/$(database)/documents/sharedAccess/$(ownerId + '_' + viewerId));
    }
    
    function hasScope(ownerId, viewerId, requiredScope) {
      return hasSharedAccess(ownerId, viewerId) && 
             get(/databases/$(database)/documents/sharedAccess/$(ownerId + '_' + viewerId)).data.scopes != null &&
             requiredScope in get(/databases/$(database)/documents/sharedAccess/$(ownerId + '_' + viewerId)).data.scopes;
    }

    // Invitations for family sharing (new model)
    match /invitations/{invitationId} {
      // Allow creation by inviter (owner)
      allow create: if isAuthenticated() 
        && request.resource.data.inviterId == request.auth.uid
        && request.resource.data.role == 'viewer'
        && request.resource.data.status == 'pending'
        && request.resource.data.keys().hasAll(['inviterId', 'inviteeContact', 'role', 'status', 'inviteCode', 'expiresAt', 'createdAt', 'updatedAt'])
        && request.resource.data.inviteCode is string
        && request.resource.data.inviteCode.size() >= 6
        && request.resource.data.expiresAt is timestamp
        && request.resource.data.createdAt is timestamp
        && request.resource.data.updatedAt is timestamp;
      
      // Allow read by inviter
      allow read: if isAuthenticated() && request.auth.uid == resource.data.inviterId;
      
      // Allow acceptance via backend functions only (status update)
      allow update: if isBackendFunction() && 
        request.resource.data.diff(resource.data).affectedKeys().hasOnly(['status', 'updatedAt'])
        && request.resource.data.status in ['accepted', 'revoked'];
      
      // Allow deletion by inviter
      allow delete: if isAuthenticated() && request.auth.uid == resource.data.inviterId;
    }

    // Shared access permissions (new model)
    match /sharedAccess/{accessId} {
      // Allow read by owner or viewer
      allow read: if isAuthenticated() && 
        (request.auth.uid == resource.data.ownerId || request.auth.uid == resource.data.viewerId);
      
      // Allow creation by backend functions only
      allow create: if isBackendFunction()
        && request.resource.data.keys().hasAll(['ownerId', 'viewerId', 'scopes', 'createdAt', 'updatedAt'])
        && request.resource.data.ownerId is string
        && request.resource.data.viewerId is string
        && request.resource.data.scopes is list
        && request.resource.data.createdAt is timestamp
        && request.resource.data.updatedAt is timestamp;
      
      // Allow updates by owner via backend functions only
      allow update: if isBackendFunction() && 
        request.resource.data.ownerId == resource.data.ownerId &&
        request.resource.data.diff(resource.data).affectedKeys().hasOnly(['scopes', 'updatedAt']);
      
      // Allow deletion by owner via backend functions only
      allow delete: if isBackendFunction() && 
        request.auth.uid == resource.data.ownerId;
    }

    // ===== REFERRAL PROGRAM COLLECTIONS =====
    
    // Referrals tracking
    match /referrals/{referralId} {
      allow create: if isAuthenticated() 
        && request.resource.data.referredUserId == request.auth.uid
        && request.resource.data.status in ['pending', 'completed', 'expired']
        && request.resource.data.keys().hasAll(['referrerUserId', 'referredUserId', 'referralCode', 'status', 'createdAt'])
        && request.resource.data.createdAt is timestamp;
      allow read: if isOwner(resource.data.referrerUserId) || 
        isOwner(resource.data.referredUserId);
      allow update: if isAuthenticated() && 
        request.resource.data.status == 'completed' 
        && request.auth.uid == resource.data.referredUserId;
    }

    // Promo codes (read-only for users)
    match /promoCodes/{code} {
      allow read: if isAuthenticated();
      allow write: if false; // Admin only via backend
    }

    // ===== SUBSCRIPTION & MONETIZATION COLLECTIONS =====
    // COMMENTED OUT FOR DEMO MODE - All users have full access
    /*
    match /subscriptionStatus/{userId} {
      allow read: if isOwner(userId);
      allow create: if isOwner(userId) 
        && request.resource.data.keys().hasAll(['userId', 'plan', 'status', 'startDate'])
        && request.resource.data.status in ['active', 'trial', 'inactive', 'cancelled']
        && request.resource.data.createdAt is timestamp;
      allow update: if isOwner(userId) 
        && request.resource.data.diff(resource.data).affectedKeys().hasOnly([
          'status', 'plan', 'endDate', 'updatedAt', 'stripeCustomerId', 'stripeSubscriptionId'
        ]);
    }

    // Payment history (read-only for users)
    match /paymentHistory/{paymentId} {
      allow read: if isOwner(resource.data.userId);
      allow write: if false; // Stripe webhook only
    }

    // Gift cards
    match /giftCards/{giftCardId} {
      allow read: if isAuthenticated() && 
        (isOwner(resource.data.recipientUserId) || isOwner(resource.data.senderUserId));
      allow create: if isAuthenticated() 
        && request.resource.data.senderUserId == request.auth.uid
        && request.resource.data.keys().hasAll(['senderUserId', 'recipientEmail', 'amount', 'code', 'status'])
        && request.resource.data.status in ['pending', 'redeemed', 'expired']
        && request.resource.data.createdAt is timestamp;
      allow update: if isAuthenticated() && 
        request.resource.data.status == 'redeemed' 
        && request.auth.uid == resource.data.recipientUserId;
    }
    */

    // ===== SUBSCRIPTION FEATURES COLLECTIONS =====
    // DEMO MODE: All users have unlimited access
    // AI credits tracking
    match /aiCredits/{userId} {
      allow read: if isOwner(userId);
      allow write: if isOwner(userId); // Demo: unlimited credits
    }

    // Feature flags for subscription tiers
    match /featureFlags/{userId} {
      allow read: if isOwner(userId);
      allow write: if false; // Managed by backend
    }
  }
}