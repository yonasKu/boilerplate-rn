# Recaps Backend Trigger Plan

This document defines how and when Weekly/Monthly/Yearly recaps are generated by the backend, aligned with the app’s Home screen UX. The Home page surfaces a Home-only “Weekly Recap Snippet” (wording only) that does not change backend generators.

## Goals
- Replace any client-side ad‑hoc recap generation with reliable backend triggers.
- At 3 entries in the current week, surface a Home-only “Weekly Recap Snippet” (ephemeral UI). Do not persist a recap document at this threshold.
- Allow a manual save from Home that creates a non-listed recap document of type `weekly_snippet` (not `weekly`).
- Generate Monthly at 5+ entries in month; Yearly at 10+ entries in year (persisted as `monthly`/`yearly`).
- Keep the Home screen CTA logic consistent with backend behavior and wording.

## Current Implementation (backend)
- Firestore trigger: `functions/functions/onJournalEntry.js`
  - `onJournalEntryCreated` fires on `journalEntries` create and calls `checkAndGenerateRecaps(userId, childIds)`.
  - Thresholds implemented:
    - Weekly: 3 entries in week
    - Monthly: 5 entries in month
    - Yearly: 10 entries in year
- Generator service: `functions/services/recapGenerator.js`
  - `generateWeeklyRecap(userId, childId, { start, end })`
  - `generateMonthlyRecap(...)`, `generateYearlyRecap(...)`
  - Saves recap to `recaps` collection and sends a push notification via `NotificationService`.
- HTTP/Callable endpoints (optional/manual):
  - `functions/functions/callable/recaps.js`
  - `functions/functions/http/recaps.js`
- Schedules (batch): `functions/recaps/weeklyAutoGenerator.js`
  - Runs Mondays 09:00 America/New_York to backfill previous week for all active users.

## Current Implementation (app)
- Home screen: `src/features/home/screens/HomeScreen.tsx`
  - Computes entries in current week (`countThisWeek`).
  - Shows mid‑page CTA: “Catch up on this week” until `countThisWeek >= 3`, then success message.
  - Shows a Home-only wording “Weekly Recap Snippet” where appropriate; this is nomenclature only and does not affect backend logic.
  - Shows `WeeklyRecapPreviewCard` regardless; backend determines if a recap exists.

## Proposed Behavior (subtle UX-first adjustment)
- Weekly: when a user reaches 3 entries in the current week, display a Home-only “Weekly Recap Snippet.” Do not save a recap document for this threshold.
- Monthly/Yearly: continue using backend generation based on thresholds or scheduled jobs; those are persisted recaps.
- Keep the Home weekly CTA rule as-is (threshold = 3); it now maps to the snippet, not a saved recap.

Optionally, expose a user tap trigger on Home that calls the existing callable to request the same current-week recap range. This does not alter generation rules, and only initiates the existing flow.

## Idempotency & De-duplication (backend change)
- Problem: multiple recaps can be created for the same user/child/period/type when multiple triggers fire (entry-create, schedule, HTTP).
- Solution: enforce a deterministic recap identity and upsert once.

Design
- Deterministic key (journal-level): `recapKey = sha1(`${userId}|${type}|${periodStartISO}|${periodEndISO}`)`
- Deterministic doc path: `recaps/{recapKey}` instead of random `add()`
- Transactional create-if-absent:
  - In generator (`generateWeeklySnippet`/monthly/yearly), compute `recapKey` and `docRef = db.collection('recaps').doc(recapKey)`
  - Run a transaction: if `docRef` exists, return `{ success: true, id: recapKey, alreadyExists: true }`; else set the recap document and then notify.
- Mark provenance: `source: 'auto' | 'http' | 'schedule'`, `idempotencyKey: recapKey`.
- Optional: store `requestId` from caller to ease tracing.

Impacts
- Prevents duplicates from concurrent triggers or retries.
- HTTP endpoints are naturally idempotent (same inputs → same recapKey → no duplicate).

Indexes
- Typical queries remain on `userId` (journal scope), `type`, `period.startDate`, `period.endDate`. No unique index needed because we control the doc ID.

Tonight’s usage
- Use only HTTP endpoints (see below). No callable usage needed.

### Journal scope and “single recap” rule
- Goal (per product): each user has a single journal; there should be only ONE recap per period for that journal.
- Scope change: treat recaps as journal-scoped, not per-child. For now, when a user selects a child to journal about, it still belongs to the same journal; weekly recap aggregates across the chosen child context but stores ONE recap keyed by the journal.

API and data model adjustments
- Replace `childId` with `journalId` in recap generation inputs. If the app is single-journal-per-user, use `journalId = userId` for now to avoid schema churn.
- Idempotency key becomes: `sha1(`${journalId}|${type}|${periodStartISO}|${periodEndISO}`)`
- Document path: `recaps/{recapKey}` where `recapKey` is computed above.
- Keep optional fields for analytics: `childIdsAggregated: string[]` (set to those present in the period), `source: 'auto' | 'http' | 'schedule'`, `idempotencyKey`.

Transaction-based upsert
- In `AutomatedRecapService.generateWeeklyRecap()` / monthly / yearly:
  - Compute `recapKey` using journal scope.
  - `docRef = db.collection('recaps').doc(recapKey)`
  - Run a transaction: if exists → return `{ success: true, id: recapKey, alreadyExists: true }`; else → build recap payload and `set()` it atomically, then send notification.

Concurrency and retries
- All entry triggers, schedules, and HTTP routes call the same service and thus collide on the same `recapKey`, ensuring one winner and zero duplicates.
- Clients may safely retry; they’ll receive `alreadyExists=true`.

Indexes and queries
- Primary listing query on Recaps page stays by `userId` (or `journalId`) + `type` + period range.
- No unique Firestore index required; uniqueness guaranteed by deterministic doc ID.

Migration plan (concise)
1) Deploy service changes using `journalId` and deterministic `recapKey`.
2) Backfill: for each user and each period, identify duplicate weekly recaps; keep the newest (or the one with richest content), delete others or mark as `status='superseded'` and add `supersededBy: <recapKey>`.
3) Optional: add a tiny HTTP admin tool to dedupe historical docs once.
4) Client: if currently passing `childId`, keep accepting it but map to `journalId = userId` in the HTTP handler temporarily to avoid app changes.

Visibility policy (no functional change now)
- Home uses “Weekly Recap Snippet” wording; Recaps page lists persisted weekly docs.
- If product later wants some generated items to be hidden from Recaps, add `visibility: 'home_only' | 'listed'` and filter client-side accordingly. Not required for idempotency.

## User-scoped aggregation (aggregate ALL children)
Goal: generate ONE recap per user per period, aggregating entries across all their children.

Backend changes (precise locations)
- `functions/services/journalAggregator.js`
  - `aggregateJournalEntries()`
    - Make `childId` optional.
    - Update `validateInputs()` to not require `childId`.
    - Update `buildOptimizedQuery()` to query by `userId` and date range only:
      - Remove `.where('childIds', 'array-contains', childId)`
      - Keep: `.where('userId','==',userId).where('createdAt','>=',startDate).where('createdAt','<=',endDate).orderBy('createdAt','desc')`
    - Remove `getChildDetails()` call or make it optional; set `childName`/`childAge` generically or derive from entries.
    - Keep `analyzeChildren()` to compute unique child IDs from entries.
  - Output should include:
    - `summary.children.uniqueChildren` (array of childIds)
    - Other summaries unchanged.

- `functions/services/recapGenerator.js`
  - In `generateWeeklyRecap` / `generateMonthlyRecap` / `generateYearlyRecap`:
    - Call `journalAggregator.aggregateJournalEntries({ userId, /* childId optional */ type, startDate, endDate })`.
    - Compute `recapKey` with `journalId=userId` (see idempotency section).
    - Build recap payload with:
      - `userId`
      - `type`
      - `period { startDate, endDate }`
      - `childIdsAggregated: journalData.summary.children.uniqueChildren`
      - Optional: remove `childId` field (or keep null for back-compat during migration).

- `functions/functions/http/recaps.js`
  - Accept `{ childId }` but ignore it for generation; use `decoded.uid` as journalId/user scope.
  - Pass `source='http'` to service.

- `functions/functions/onJournalEntry.js` and `functions/recaps/weeklyAutoGenerator.js`
  - Call service with `userId` only; do not iterate per child.
  - Pass `source='auto'` / `source='schedule'` respectively.

Queries and UI impact
- Recaps page queries by `userId` + `type` + period; content represents all children.
- To show which kids were included, read `childIdsAggregated` on each recap.

Security rules
- No change required for reads. Creates are via functions. Existing relaxed rules for journal entry creation remain valid.

## Date Sources and Consistency
- Counting uses Firestore `createdAt` in `onJournalEntry.js`:
  - Query: `where('createdAt', '>=', period.start).where('createdAt', '<=', period.end)`
- App sometimes displays based on `occurredAt` (fallback `createdAt`). For backend thresholds, we’ll continue to use `createdAt` unless product requires switching to `occurredAt`.

## Period Calculations
- Weekly (backend trigger): `startOfWeek(now, { weekStartsOn: 1 })` → Monday–Sunday
- Monthly: `startOfMonth(now)` to `endOfMonth(now)`
- Yearly: `startOfYear(now)` to `endOfYear(now)`
- Scheduled weekly generator uses the previous week range to bulk‑generate Mondays at 9:00.

## Thresholds
- Weekly: 3 entries → generate once for the week
- Monthly: 5 entries → generate once for the month
- Yearly: 10 entries → generate once for the year

## Trigger Points
1. On every new journal entry (`onJournalEntryCreated`):
   - Count entries in active periods and generate recaps if thresholds are met.
2. Scheduled weekly backfill (`scheduledWeeklyRecaps`):
   - Monday 09:00 America/New_York for last week.
3. Manual/admin via HTTP/Callable endpoints (for ops, QA, or tap-to-trigger on Home):
   - `generateWeeklyRecap`, `generateMonthlyRecap`, `generateYearlyRecap` with explicit `{ startDate, endDate }`.

### Tap-to-trigger (callable) – Save Weekly Snippet
- Endpoint: `functions/functions/callable/recaps.js` → `saveWeeklySnippet`
- Inputs: `startDate`, `endDate` (current week range); `childId` accepted for back‑compat but ignored.
- Behavior: generates recap content for the week and persists with `type = 'weekly_snippet'`.

### HTTP-only (tonight)
- Endpoints: `functions/functions/http/recaps.js`
  - `saveWeeklySnippet` → persists `weekly_snippet` for current week
  - `generateMonthlyRecap` | `generateYearlyRecap` → persists `monthly`/`yearly`
- Auth: POST with `Authorization: Bearer <ID_TOKEN>` and `Content-Type: application/json`
- Idempotent by deterministic doc path once backend change is applied (key includes type, so `weekly_snippet` will not collide with `weekly`).

### Test Idempotency
- Call HTTP `generateWeeklyRecap` twice with the same `{ userId, startDate, endDate }`
  - Expected (when using persistence intentionally, e.g., admin/manual or schedule): first call creates, second returns `alreadyExists=true` and no duplicate doc.

## Notifications
- After a recap is saved, `recapGenerator.sendRecapNotification()` sends push and stores a notification document. Payload no longer includes `childId`; it contains `type`, `recapId` and user-scoped context.

## Edge Cases
- Users with multiple children: weekly snippet and persisted recaps aggregate across children (journal‑level). `childIdsAggregated` records which children were included.
- Mixed timestamps: Firestore server timestamp vs Date object. Counting queries expect valid `Date` range and indexed `createdAt`.
- New users: No entries → no recaps. At 3 entries, show the snippet only; persisting requires the user’s manual tap (saves `weekly_snippet`).

## Testing Guide
1. Create 2 entries in current week → no weekly recap.
2. Create 3rd entry (same week) → Home shows “Weekly Recap Snippet”; backend does not persist a recap automatically.
3. From Home, tap “Save snippet” (HTTP `saveWeeklySnippet`) → verify `recaps` contains a document with:
   - `type = 'weekly_snippet'`
   - `userId` (journal‑level)
   - `period.startDate`, `period.endDate`
   - `childIdsAggregated` present
4. Check device notification (or `notifications` collection) if enabled for snippet saves.
5. Repeat for 5 entries in a month, 10 entries in a year → `monthly`/`yearly` persisted as usual.
6. Scheduled test: ensure Monday run backfills prior week for users who missed live triggers (applies to persisted weekly if later enabled; not required for snippets).

## Manual Weekly Snippet – Backend Notes (concise)
- Service: reuse `AutomatedRecapService.generateWeeklyRecap` pipeline but persist with `type = 'weekly_snippet'` and journal scope (`journalId = userId`).
- Idempotency: key includes `type`, so `weekly_snippet` for a given week is unique and distinct from `weekly`.
- HTTP handler: `functions/functions/http/recaps.js` exposes `saveWeeklySnippet`; ignores `childId`, requires week range, uses auth `uid`.
- Visibility: by default, Recaps page filters out `weekly_snippet` unless product decides otherwise.

## Operational Notes
- Ensure `OPENAI_API_KEY` is configured in Functions env for callable/HTTP/scheduled jobs.
- Confirm Firestore indexes for queries on `journalEntries` by `userId`, `childIds`, `createdAt`.
- Timezone: Weekly cron uses America/New_York; adjust to your product’s primary TZ if needed.

## Summary
- The backend already supports auto‑generation of recaps when thresholds are reached on new entry creation.
- The Home screen CTA aligns with the weekly threshold (3 entries). No client changes are required for backend triggers.
- Use scheduled and callable endpoints for backfill and testing.
