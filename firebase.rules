rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // ===== HELPER FUNCTIONS =====
    function isAuthenticated() {
      return request.auth != null;
    }
    
    function isOwner(userId) {
      return isAuthenticated() && request.auth.uid == userId;
    }
    
    function isEmailVerified() {
      return isAuthenticated() && request.auth.token.email_verified == true;
    }
    
    function isFamilyMember(parentUserId) {
      return isAuthenticated() && 
        (request.auth.uid == parentUserId || 
         (get(/databases/$(database)/documents/users/$(request.auth.uid)).data.parentUserId == parentUserId));
    }
    
    function hasSubscriptionAccess(userId) {
      return isAuthenticated() && 
        (get(/databases/$(database)/documents/subscriptionStatus/$(userId)).data.status == 'active' ||
         get(/databases/$(database)/documents/subscriptionStatus/$(userId)).data.status == 'trial');
    }

    // ===== USERS COLLECTION =====
    match /users/{userId} {
      // Allow create if the user is creating their own document and passes validation
      allow create: if isOwner(userId)
        && request.resource.data.name is string
        && request.resource.data.name.size() > 0
        && request.resource.data.email is string
        && request.resource.data.email == request.auth.token.email
        && request.resource.data.email.matches('.*@.*\\..*')
        && request.resource.data.onboarded == false
        && request.resource.data.lifestage == null
        && request.resource.data.subscription is map
        && request.resource.data.subscription.plan is string
        && request.resource.data.subscription.status is string
        && request.resource.data.subscription.startDate is timestamp
        && request.resource.data.children is list
        && request.resource.data.children.size() == 0
        && request.resource.data.createdAt is timestamp
        && request.resource.data.onboarded is bool;

      // Allow reading own data or if a family member.
      allow read: if isOwner(userId) || isFamilyMember(userId);

      // Allow owner to update their document. A more specific rule for family sharing updates is also included.
      allow update: if isOwner(userId) ||
        (isFamilyMember(userId) && request.resource.data.diff(resource.data).affectedKeys().hasOnly([
          'profile', 'permissions', 'updatedAt', 'subscriptionStatus'
        ]));
      
      // Only the owner can delete their own document
      allow delete: if isOwner(userId);

      // --- Sub-collection for device tokens for push notifications ---
      match /devices/{deviceToken} {
        // Only the owner of the user document can manage their own device tokens.
        allow read, write: if isOwner(userId);
      }

      // --- Sub-collection for user's notification preferences ---
      match /notificationPreferences/{prefId} {
        // Only the owner can manage their notification preferences.
        allow read, write: if isOwner(userId);
      }
      
      // --- Sub-collection for in-app notifications ---
      match /notifications/{notificationId} {
        // Owner can read and update (e.g., mark as read) their notifications.
        allow read, update: if isOwner(userId);
        // Notifications should only be created by the backend, not the client.
        allow create, delete: if false;
      }
    }

    // ========== CHILDREN COLLECTION ==========
    match /children/{childId} {
      // Users can read children documents they own
      allow read: if request.auth != null && request.auth.uid == resource.data.parentId;

      // Users can create children documents for themselves
      allow create: if request.auth != null 
        && request.resource.data.parentId == request.auth.uid
        && request.resource.data.keys().hasAll(['parentId', 'name', 'dateOfBirth', 'gender', 'createdAt', 'updatedAt'])
        && request.resource.data.name is string
        && request.resource.data.name.size() > 0
        && (request.resource.data.dateOfBirth is timestamp || request.resource.data.dateOfBirth is string)
        && request.resource.data.gender is string
        && (request.resource.data.gender in ['Boy', 'Girl', "Don't know yet", 'male', 'female', 'prefer_not_to_say'])
        && request.resource.data.createdAt is timestamp
        && request.resource.data.updatedAt is timestamp;

      // Users can update or delete children documents they own
      allow update, delete: if request.auth != null && request.auth.uid == resource.data.parentId;
    }

    // ===== JOURNAL ENTRIES COLLECTION =====
    match /journalEntries/{entryId} {
      // A user can create an entry if they are logged in and the entry's `userId` field matches their own ID.
      allow create: if isOwner(request.resource.data.userId)
        && request.resource.data.keys().hasAll(['userId', 'text', 'childIds'])
        && request.resource.data.text is string
        && request.resource.data.childIds is list
        && request.resource.data.childIds.size() > 0
        && (request.resource.data.media == null || request.resource.data.media is list)
        && (request.resource.data.isFavorited == null || request.resource.data.isFavorited is bool)
        && (request.resource.data.isMilestone == null || request.resource.data.isMilestone is bool)
        && (request.resource.data.childAgeAtEntry == null || request.resource.data.childAgeAtEntry is string)
        && (request.resource.data.likes == null || request.resource.data.likes is map)
      
      // A user can read entries they own or that are shared with them as a family member
      allow read: if isFamilyMember(resource.data.userId);
      
      // A user can update their own entry's content and tags.
      // Family members can also update likes and favorites.
      allow update: if (isOwner(resource.data.userId) && 
                       request.resource.data.diff(resource.data).affectedKeys().hasOnly(['text', 'isFavorited', 'isMilestone', 'media', 'updatedAt', 'likes', 'childIds', 'childAgeAtEntry'])) ||
                      (isFamilyMember(resource.data.userId) && 
                       request.resource.data.diff(resource.data).affectedKeys().hasOnly(['likes', 'isFavorited']));
      
      // A user can delete their own entry
      allow delete: if isOwner(resource.data.userId);
    }

    // ===== RECAPS COLLECTION =====
    match /recaps/{recapId} {
      // Recaps can be read by family members
      allow read: if isFamilyMember(resource.data.userId);

      // Owners can create recaps
      allow create: if isOwner(request.resource.data.userId)
        && request.resource.data.keys().hasAll(['userId', 'childId', 'type', 'period', 'status', 'createdAt'])
        && request.resource.data.type in ['weekly', 'monthly', 'yearly']
        && request.resource.data.status in ['generating', 'completed', 'failed']
        && request.resource.data.period.startDate is timestamp
        && request.resource.data.period.endDate is timestamp
        && request.resource.data.createdAt is timestamp;

      // Owners can update their recaps
      allow update: if isOwner(resource.data.userId)
        && request.resource.data.diff(resource.data).affectedKeys().hasOnly([
          'aiGenerated', 'media', 'status', 'updatedAt'
        ]);

      // Owners can delete their recaps
      allow delete: if isOwner(resource.data.userId);
    }

    // ===== FAMILY SHARING COLLECTIONS =====
    

    // Invitations for family sharing
    match /invitations/{invitationId} {
      allow create: if isAuthenticated() 
        && request.resource.data.senderUserId == request.auth.uid
        && request.resource.data.invitationType in ['family_view', 'upgrade']
        && request.resource.data.status in ['pending', 'accepted', 'declined', 'expired']
        && request.resource.data.keys().hasAll(['senderUserId', 'recipientEmail', 'invitationType', 'status', 'createdAt'])
        && request.resource.data.createdAt is timestamp;
      allow read: if isOwner(resource.data.senderUserId) || 
        (isAuthenticated() && request.auth.token.email == resource.data.recipientEmail);
      allow update: if isAuthenticated() && 
        request.resource.data.status in ['accepted', 'declined'] 
        && request.auth.uid == resource.data.recipientUserId;
      allow delete: if isOwner(resource.data.senderUserId);
    }

    // Shared access permissions
    match /sharedAccess/{accessId} {
      allow read: if isOwner(resource.data.granteeUserId) || 
        isOwner(resource.data.grantorUserId);
      allow create: if isOwner(request.resource.data.grantorUserId)
        && request.resource.data.keys().hasAll(['grantorUserId', 'granteeUserId', 'permissions', 'createdAt'])
        && request.resource.data.createdAt is timestamp;
      allow update: if isOwner(resource.data.grantorUserId);
      allow delete: if isOwner(resource.data.grantorUserId);
    }

    // ===== REFERRAL PROGRAM COLLECTIONS =====
    
    // Referrals tracking
    match /referrals/{referralId} {
      allow create: if isAuthenticated() 
        && request.resource.data.referredUserId == request.auth.uid
        && request.resource.data.status in ['pending', 'completed', 'expired']
        && request.resource.data.keys().hasAll(['referrerUserId', 'referredUserId', 'referralCode', 'status', 'createdAt'])
        && request.resource.data.createdAt is timestamp;
      allow read: if isOwner(resource.data.referrerUserId) || 
        isOwner(resource.data.referredUserId);
      allow update: if isAuthenticated() && 
        request.resource.data.status == 'completed' 
        && request.auth.uid == resource.data.referredUserId;
    }

    // Promo codes (read-only for users)
    match /promoCodes/{code} {
      allow read: if isAuthenticated();
      allow write: if false; // Admin only via backend
    }

    // ===== SUBSCRIPTION & MONETIZATION COLLECTIONS =====
    // COMMENTED OUT FOR DEMO MODE - All users have full access
    // Uncomment when integrating Stripe/RevenueCat
    /*
    match /subscriptionStatus/{userId} {
      allow read: if isOwner(userId);
      allow create: if isOwner(userId) 
        && request.resource.data.keys().hasAll(['userId', 'plan', 'status', 'startDate'])
        && request.resource.data.status in ['active', 'trial', 'inactive', 'cancelled']
        && request.resource.data.createdAt is timestamp;
      allow update: if isOwner(userId) 
        && request.resource.data.diff(resource.data).affectedKeys().hasOnly([
          'status', 'plan', 'endDate', 'updatedAt', 'stripeCustomerId', 'stripeSubscriptionId'
        ]);
    }

    // Payment history (read-only for users)
    match /paymentHistory/{paymentId} {
      allow read: if isOwner(resource.data.userId);
      allow write: if false; // Stripe webhook only
    }

    // Gift cards
    match /giftCards/{giftCardId} {
      allow read: if isAuthenticated() && 
        (isOwner(resource.data.recipientUserId) || isOwner(resource.data.senderUserId));
      allow create: if isAuthenticated() 
        && request.resource.data.senderUserId == request.auth.uid
        && request.resource.data.keys().hasAll(['senderUserId', 'recipientEmail', 'amount', 'code', 'status'])
        && request.resource.data.status in ['pending', 'redeemed', 'expired']
        && request.resource.data.createdAt is timestamp;
      allow update: if isAuthenticated() && 
        request.resource.data.status == 'redeemed' 
        && request.auth.uid == resource.data.recipientUserId;
    }
    */

    // ===== SUBSCRIPTION FEATURES COLLECTIONS =====
    // DEMO MODE: All users have unlimited access
    // AI credits tracking
    match /aiCredits/{userId} {
      allow read: if isOwner(userId);
      allow write: if isOwner(userId); // Demo: unlimited credits
    }

    // Feature flags for subscription tiers
    match /featureFlags/{userId} {
      allow read: if isOwner(userId);
      allow write: if false; // Managed by backend
    }
  }
}
